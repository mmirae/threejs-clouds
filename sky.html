<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>sky</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const loader = new THREE.TextureLoader();
    const textures = [];

    const clickableClouds = [];
    const clickedClouds = new Map();

    // 마우스 클릭 감지용
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // 클릭 이벤트
    document.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableClouds);

      if (intersects.length > 0) {
        const clicked = intersects[0].object;
        clickedClouds.set(clicked, { scale: 1.4, speed: 0.05 });
      }
    });

    // 이미지 두 개 로딩
    Promise.all([
      loader.loadAsync('./cloud.png'),
      loader.loadAsync('./bigcloud.png')
    ]).then(([texture1, texture2]) => {
      textures.push(texture1, texture2);
      const cloudGroup = new THREE.Group();
      scene.add(cloudGroup);

      const numClouds = 60;
      for (let i = 0; i < numClouds; i++) {
        const texture = textures[Math.floor(Math.random() * textures.length)];
        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.8,
        });

        const sprite = new THREE.Sprite(material);
        const scale = 10 + Math.random() * 10;
        sprite.scale.set(scale, scale * 0.6, 1);
        sprite.position.set(
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 50,
          (Math.random() - 0.5) * 50
        );
        cloudGroup.add(sprite);
        clickableClouds.push(sprite); // 클릭 가능하게 등록
      }

      let mouseX = 0;
      let mouseY = 0;
      const windowHalfX = window.innerWidth / 2;
      const windowHalfY = window.innerHeight / 2;

      document.addEventListener('mousemove', (event) => {
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      });

      function animate() {
        requestAnimationFrame(animate);

        const factor = 0.001;
        cloudGroup.position.x +=
          (mouseX * factor - cloudGroup.position.x) * 0.1;
        cloudGroup.position.y +=
          (-mouseY * factor - cloudGroup.position.y) * 0.1;

        cloudGroup.children.forEach((sprite, idx) => {
          sprite.position.x += 0.02 * (idx % 2 === 0 ? 1 : -1);
          if (sprite.position.x > 50) sprite.position.x = -50;
          if (sprite.position.x < -50) sprite.position.x = 50;
        });

        // 클릭된 구름 확대-축소 애니메이션
        clickedClouds.forEach((data, sprite) => {
          const targetScale = 1;
          const currentScale = sprite.scale.x;
          const newScale = currentScale - data.speed;

          if (newScale <= sprite.userData.originalScale || newScale <= targetScale) {
            const s = sprite.userData.originalScale || targetScale;
            sprite.scale.set(s, s * 0.6, 1);
            clickedClouds.delete(sprite);
          } else {
            sprite.scale.set(newScale, newScale * 0.6, 1);
          }
        });

        renderer.render(scene, camera);
      }

      animate();
    }).catch(err => {
      console.error('텍스처 로딩 오류:', err);
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
